using Microsoft.Extensions.DependencyInjection;
using ResultBoxes;
using Sekiban.Core.Aggregate;
using Sekiban.Core.Command;
using Sekiban.Core.Documents;
using Sekiban.Core.Documents.Pools;
using Sekiban.Core.Events;
using Sekiban.Core.Exceptions;
using Sekiban.Core.PubSub;
using Sekiban.Core.Query.SingleProjections;
using Sekiban.Core.Types;
using Sekiban.Core.Validation;
using System.Collections.Immutable;
using System.ComponentModel.DataAnnotations;
using System.Reflection;
namespace Sekiban.Testing.Command;

/// <summary>
///     Command executor for testing
/// </summary>
public class TestCommandExecutor(IServiceProvider serviceProvider)
{
    /// <summary>
    ///     Events that were generated by the last command execution
    /// </summary>
    public ImmutableList<IEvent> LatestEvents { get; set; } = ImmutableList<IEvent>.Empty;
    /// <summary>
    ///     Execute command and returns aggregate id
    /// </summary>
    /// <param name="command"></param>
    /// <param name="injectingAggregateId">If you want use certain aggregate Id, you can inject here, otherwise, pass null</param>
    /// <typeparam name="TAggregatePayload"></typeparam>
    /// <returns></returns>
    public Guid ExecuteCommand<TAggregatePayload>(
        ICommandCommon<TAggregatePayload> command,
        Guid? injectingAggregateId = null) where TAggregatePayload : IAggregatePayloadCommon =>
        ExecuteCommandPrivate(command, injectingAggregateId, false);
    /// <summary>
    ///     Execute command and returns aggregate id
    ///     Also publish events and all local subscriptions will be executed
    /// </summary>
    /// <param name="command"></param>
    /// <param name="injectingAggregateId">If you want use certain aggregate Id, you can inject here, otherwise, pass null</param>
    /// <typeparam name="TAggregatePayload"></typeparam>
    /// <returns></returns>
    public Guid ExecuteCommandWithPublish<TAggregatePayload>(
        ICommandCommon<TAggregatePayload> command,
        Guid? injectingAggregateId = null) where TAggregatePayload : IAggregatePayloadCommon =>
        ExecuteCommandPrivate(command, injectingAggregateId, true);
    /// <summary>
    ///     Execute command and returns aggregate id
    ///     Also publish events and all local subscriptions will be executed
    ///     Even non blocking subscriptions will be executed by same thread and block the execution
    ///     (To test subscription values, use this method. But be careful, orders could be different from actual
    ///     execution)
    /// </summary>
    /// <param name="command"></param>
    /// <param name="injectingAggregateId"></param>
    /// <typeparam name="TAggregatePayload"></typeparam>
    /// <returns></returns>
    /// <exception cref="Exception"></exception>
    public Guid ExecuteCommandWithPublishAndBlockingSubscriptions<TAggregatePayload>(
        ICommandCommon<TAggregatePayload> command,
        Guid? injectingAggregateId = null) where TAggregatePayload : IAggregatePayloadCommon
    {
        var nonBlockingStatus = serviceProvider.GetService<EventNonBlockingStatus>() ??
            throw new SekibanTypeNotFoundException("EventNonBlockingStatus could not be found.");
        return nonBlockingStatus.RunBlockingFunc(() => ExecuteCommandPrivate(command, injectingAggregateId, true));
    }

    private Guid ExecuteCommandPrivate<TAggregatePayload>(
        ICommandCommon<TAggregatePayload> command,
        Guid? injectingAggregateId,
        bool withPublish) where TAggregatePayload : IAggregatePayloadCommon
    {
        var rootPartitionKey = command.GetRootPartitionKey();
        var validationResults = command.ValidateProperties().ToList();
        if (validationResults.Count != 0)
        {
            throw new ValidationException($"{command.GetType().Name} command validation failed :" + validationResults);
        }

        var baseType = typeof(ICommandHandlerCommon<,>);
        var genericType = baseType.MakeGenericType(typeof(TAggregatePayload), command.GetType());

        if (command is ICommandConverterCommon converter)
        {
            var handler = serviceProvider.GetService(genericType) ??
                throw new SekibanCommandNotRegisteredException(command.GetType().Name);
            if (((dynamic)handler).ConvertCommand((dynamic)converter) is ICommandCommon convertedCommand)
            {
                var method = GetType()
                    .GetMethod(nameof(ExecuteCommandPrivate), BindingFlags.NonPublic | BindingFlags.Instance);
                var param1 = convertedCommand.GetType().GetAggregatePayloadTypeFromCommandType();
                var generated = method?.MakeGenericMethod(param1);
                if (generated is not null)
                {
                    return generated.Invoke(
                            this,
                            new object?[] { convertedCommand, injectingAggregateId, withPublish }) as Guid? ??
                        throw new SekibanTypeNotFoundException("Failed to get result of WhenCommandPrivate method");
                }
            }
        }
        var aggregateId = injectingAggregateId ??
            CommandExecutor.GetAggregateId<TAggregatePayload>(command, serviceProvider);
        if (command is ICommandWithoutLoadingAggregateCommon && command is not ICommandWithHandlerCommon)
        {
            var handler = serviceProvider.GetService(genericType) ??
                throw new SekibanCommandNotRegisteredException(command.GetType().Name);
            var commandDocumentBaseType = typeof(CommandDocument<>);
            var commandDocumentType = commandDocumentBaseType.MakeGenericType(command.GetType());
            var commandDocument = Activator.CreateInstance(
                commandDocumentType,
                aggregateId,
                command,
                typeof(TAggregatePayload),
                rootPartitionKey,
                null);

            var baseClass = typeof(CommandWithoutLoadingAggregateHandlerAdapter<,>);
            var adapterClass = baseClass.MakeGenericType(typeof(TAggregatePayload), command.GetType());
            var adapter = Activator.CreateInstance(adapterClass) ??
                throw new SekibanTypeNotFoundException("Method not found");
            var method = adapterClass.GetMethod(nameof(ICommandHandlerAdapterCommon.HandleCommandAsync));
            var commandResponse
                = (CommandResponse)((dynamic?)method?.Invoke(
                        adapter,
                        [commandDocument, handler, aggregateId, rootPartitionKey]) ??
                    throw new SekibanCommandHandlerNotMatchException(
                        "Command failed to execute " + command.GetType().Name))
                .Result;
            LatestEvents = commandResponse.Events;
        } else if (command is ICommandWithoutLoadingAggregateCommon && command is ICommandWithHandlerCommon)
        {
            var commandDocumentBaseType = typeof(CommandDocument<>);
            var commandDocumentType = commandDocumentBaseType.MakeGenericType(command.GetType());
            var commandDocument = Activator.CreateInstance(
                commandDocumentType,
                aggregateId,
                command,
                typeof(TAggregatePayload),
                rootPartitionKey,
                null);

            var baseClass = typeof(StaticCommandWithoutLoadingAggregateHandlerAdapter<,>);
            var adapterClass = baseClass.MakeGenericType(typeof(TAggregatePayload), command.GetType());
            var adapter = Activator.CreateInstance(adapterClass, serviceProvider) ??
                throw new SekibanTypeNotFoundException("Method not found");
            var method = adapterClass.GetMethod(nameof(ICommandHandlerAdapterCommon.HandleCommandAsync));
            var commandResponse
                = (ResultBox<CommandResponse>)((dynamic?)method?.Invoke(
                        adapter,
                        [commandDocument, aggregateId, rootPartitionKey]) ??
                    throw new SekibanCommandHandlerNotMatchException(
                        "Command failed to execute " + command.GetType().Name))
                .Result;
            commandResponse.Scan(value => LatestEvents = value.Events);
        } else if (command is ICommandWithHandlerCommon)
        {
            var commandDocumentBaseType = typeof(CommandDocument<>);
            var commandDocumentType = commandDocumentBaseType.MakeGenericType(command.GetType());
            var commandDocument = Activator.CreateInstance(
                commandDocumentType,
                aggregateId,
                command,
                typeof(TAggregatePayload),
                rootPartitionKey,
                null);

            var aggregateLoader = serviceProvider.GetRequiredService(typeof(IAggregateLoader)) as IAggregateLoader ??
                throw new SekibanTypeNotFoundException("Failed to get AddAggregate Service");
            var baseClass = typeof(StaticCommandHandlerAdapter<,,>);
            var parent = typeof(TAggregatePayload).GetBaseAggregatePayloadTypeFromAggregate();
            var adapterClass = baseClass.MakeGenericType(parent, typeof(TAggregatePayload), command.GetType());
            var adapter = Activator.CreateInstance(adapterClass, aggregateLoader, serviceProvider, false) ??
                throw new SekibanTypeNotFoundException("Method not found");
            var method = adapterClass.GetMethod(nameof(ICommandHandlerAdapterCommon.HandleCommandAsync)) ??
                throw new SekibanTypeNotFoundException("HandleCommandAsync not found");
            var commandResponse
                = (ResultBox<CommandResponse>)((dynamic?)method.Invoke(
                        adapter,
                        [commandDocument, aggregateId, rootPartitionKey]) ??
                    throw new SekibanCommandHandlerNotMatchException(
                        "Command failed to execute " + command.GetType().Name))
                .Result;
            commandResponse.Scan(success => LatestEvents = success.Events);
        } else if (command is not ICommandWithoutLoadingAggregateCommon)
        {
            var handler = serviceProvider.GetService(genericType) ??
                throw new SekibanCommandNotRegisteredException(command.GetType().Name);
            var commandDocumentBaseType = typeof(CommandDocument<>);
            var commandDocumentType = commandDocumentBaseType.MakeGenericType(command.GetType());
            var commandDocument = Activator.CreateInstance(
                commandDocumentType,
                aggregateId,
                command,
                typeof(TAggregatePayload),
                rootPartitionKey,
                null);

            var aggregateLoader = serviceProvider.GetRequiredService(typeof(IAggregateLoader)) as IAggregateLoader ??
                throw new SekibanTypeNotFoundException("Failed to get AddAggregate Service");
            var baseClass = typeof(CommandHandlerAdapter<,>);
            var adapterClass = baseClass.MakeGenericType(typeof(TAggregatePayload), command.GetType());
            var adapter = Activator.CreateInstance(adapterClass, aggregateLoader, serviceProvider, false) ??
                throw new SekibanTypeNotFoundException("Adapter not found");

            var method = adapterClass.GetMethod(nameof(ICommandHandlerAdapterCommon.HandleCommandAsync)) ??
                throw new SekibanTypeNotFoundException("HandleCommandAsync not found");

            var commandResponse
                = (CommandResponse)((dynamic?)method.Invoke(
                        adapter,
                        [commandDocument, handler, aggregateId, rootPartitionKey]) ??
                    throw new SekibanCommandHandlerNotMatchException(
                        "Command failed to execute " + command.GetType().Name))
                .Result;

            LatestEvents = commandResponse.Events;
        }

        var documentWriter = serviceProvider.GetService<EventWriter>() ??
            throw new SekibanTypeNotFoundException("Failed to get document writer");
        foreach (var e in LatestEvents)
        {
            documentWriter
                .SaveEvents(new List<IEvent> { e }, new AggregateWriteStream(typeof(TAggregatePayload)), withPublish)
                .Wait();
        }
        return aggregateId;
    }
    /// <summary>
    ///     Get all aggregate events for a aggregate.
    ///     Aggregate can be specified by aggregateId and rootPartitionKey and aggregateType.
    /// </summary>
    /// <param name="aggregateId"></param>
    /// <param name="rootPartitionKey"></param>
    /// <typeparam name="TAggregatePayload"></typeparam>
    /// <returns></returns>
    /// <exception cref="Exception"></exception>
    public IReadOnlyCollection<IEvent> GetAllAggregateEvents<TAggregatePayload>(
        Guid aggregateId,
        string rootPartitionKey = IDocument.DefaultRootPartitionKey) where TAggregatePayload : IAggregatePayloadCommon
    {
        var toReturn = new List<IEvent>();
        var eventRepository = serviceProvider.GetService<EventRepository>() ??
            throw new SekibanTypeNotFoundException("Failed to get document repository");
        eventRepository
            .GetEvents(
                EventRetrievalInfo.FromNullableValues(
                    rootPartitionKey,
                    new AggregateTypeStream<TAggregatePayload>(),
                    aggregateId,
                    ISortableIdCondition.None),
                eventObjects => { toReturn.AddRange(eventObjects); })
            .Wait();
        return toReturn;
    }
}
