using Microsoft.Extensions.DependencyInjection;
using Sekiban.Core.Aggregate;
using Sekiban.Core.Command;
using Sekiban.Core.Documents;
using Sekiban.Core.Events;
using Sekiban.Core.Exceptions;
using Sekiban.Core.Partition;
using Sekiban.Core.PubSub;
using Sekiban.Core.Query.SingleProjections;
using Sekiban.Core.Validation;
using System.Collections.Immutable;
using System.ComponentModel.DataAnnotations;
namespace Sekiban.Testing.Command;

/// <summary>
///     Command executor for testing
/// </summary>
public class TestCommandExecutor(IServiceProvider serviceProvider)
{
    /// <summary>
    ///     Events that were generated by the last command execution
    /// </summary>
    public ImmutableList<IEvent> LatestEvents { get; set; } = ImmutableList<IEvent>.Empty;
    /// <summary>
    ///     Execute command and returns aggregate id
    /// </summary>
    /// <param name="command"></param>
    /// <param name="injectingAggregateId">If you want use certain aggregate Id, you can inject here, otherwise, pass null</param>
    /// <typeparam name="TAggregatePayload"></typeparam>
    /// <returns></returns>
    public Guid ExecuteCommand<TAggregatePayload>(ICommand<TAggregatePayload> command, Guid? injectingAggregateId = null)
        where TAggregatePayload : IAggregatePayloadCommon =>
        ExecuteCommand(command, injectingAggregateId, false);
    /// <summary>
    ///     Execute command and returns aggregate id
    ///     Also publish events and all local subscriptions will be executed
    /// </summary>
    /// <param name="command"></param>
    /// <param name="injectingAggregateId">If you want use certain aggregate Id, you can inject here, otherwise, pass null</param>
    /// <typeparam name="TAggregatePayload"></typeparam>
    /// <returns></returns>
    public Guid ExecuteCommandWithPublish<TAggregatePayload>(ICommand<TAggregatePayload> command, Guid? injectingAggregateId = null)
        where TAggregatePayload : IAggregatePayloadCommon =>
        ExecuteCommand(command, injectingAggregateId, true);
    /// <summary>
    ///     Execute command and returns aggregate id
    ///     Also publish events and all local subscriptions will be executed
    ///     Even non blocking subscriptions will be executed by same thread and block the execution
    ///     (To test subscription values, use this method. But be careful, orders could be different from actual execution)
    /// </summary>
    /// <param name="command"></param>
    /// <param name="injectingAggregateId"></param>
    /// <typeparam name="TAggregatePayload"></typeparam>
    /// <returns></returns>
    /// <exception cref="Exception"></exception>
    public Guid ExecuteCommandWithPublishAndBlockingSubscriptions<TAggregatePayload>(
        ICommand<TAggregatePayload> command,
        Guid? injectingAggregateId = null) where TAggregatePayload : IAggregatePayloadCommon
    {
        var nonBlockingStatus = serviceProvider.GetService<EventNonBlockingStatus>() ?? throw new SekibanTypeNotFoundException("EventNonBlockingStatus could not be found.");
        return nonBlockingStatus.RunBlockingFunc(() => ExecuteCommand(command, injectingAggregateId, true));
    }

    private Guid ExecuteCommand<TAggregatePayload>(ICommand<TAggregatePayload> command, Guid? injectingAggregateId, bool withPublish)
        where TAggregatePayload : IAggregatePayloadCommon
    {
        var rootPartitionKey = command.GetRootPartitionKey();
        var validationResults = command.ValidateProperties().ToList();
        if (validationResults.Count != 0)
        {
            throw new ValidationException($"{command.GetType().Name} command validation failed :" + validationResults);
        }

        var baseType = typeof(ICommandHandlerCommon<,>);
        var genericType = baseType.MakeGenericType(typeof(TAggregatePayload), command.GetType());
        var handler = serviceProvider.GetService(genericType) ?? throw new SekibanCommandNotRegisteredException(command.GetType().Name);
        var aggregateId = injectingAggregateId ?? command.GetAggregateId();
        if (command is not IOnlyPublishingCommandCommon)
        {
            var commandDocumentBaseType = typeof(CommandDocument<>);
            var commandDocumentType = commandDocumentBaseType.MakeGenericType(command.GetType());
            var commandDocument = Activator.CreateInstance(
                commandDocumentType,
                aggregateId,
                command,
                typeof(TAggregatePayload),
                rootPartitionKey,
                null);

            var aggregateLoader = serviceProvider.GetRequiredService(typeof(IAggregateLoader)) as IAggregateLoader ?? throw new SekibanTypeNotFoundException("Failed to get AddAggregate Service");
            var baseClass = typeof(CommandHandlerAdapter<,>);
            var adapterClass = baseClass.MakeGenericType(typeof(TAggregatePayload), command.GetType());
            var adapter = Activator.CreateInstance(adapterClass, aggregateLoader, false) ?? throw new SekibanTypeNotFoundException("Adapter not found");

            var method = adapterClass.GetMethod(nameof(ICommandHandlerAdapterCommon.HandleCommandAsync)) ??
                throw new SekibanTypeNotFoundException("HandleCommandAsync not found");

            var commandResponse
                = (CommandResponse)((dynamic?)method.Invoke(adapter, [commandDocument, handler, aggregateId, rootPartitionKey]) ??
                    throw new SekibanCommandHandlerNotMatchException("Command failed to execute " + command.GetType().Name)).Result;

            LatestEvents = commandResponse.Events;
        } else
        {
            var commandDocumentBaseType = typeof(CommandDocument<>);
            var commandDocumentType = commandDocumentBaseType.MakeGenericType(command.GetType());
            var commandDocument = Activator.CreateInstance(commandDocumentType, aggregateId, command, typeof(TAggregatePayload), null);

            var baseClass = typeof(OnlyPublishingCommandHandlerAdapter<,>);
            var adapterClass = baseClass.MakeGenericType(typeof(TAggregatePayload), command.GetType());
            var adapter = Activator.CreateInstance(adapterClass) ?? throw new SekibanTypeNotFoundException("Method not found");
            var method = adapterClass.GetMethod(nameof(ICommandHandlerAdapterCommon.HandleCommandAsync));
            var commandResponse
                = (CommandResponse)((dynamic?)method?.Invoke(adapter, [commandDocument, handler, aggregateId, rootPartitionKey]) ??
                    throw new SekibanCommandHandlerNotMatchException("Command failed to execute " + command.GetType().Name)).Result;
            LatestEvents = commandResponse.Events;
        }

        var documentWriter = serviceProvider.GetRequiredService(typeof(IDocumentWriter)) as IDocumentWriter ?? throw new SekibanTypeNotFoundException("Failed to get document writer");
        foreach (var e in LatestEvents)
        {
            if (withPublish)
            {
                documentWriter.SaveAndPublishEvents(new List<IEvent> { e }, typeof(TAggregatePayload)).Wait();
            } else
            {
                documentWriter.SaveAsync(e, typeof(TAggregatePayload)).Wait();
            }
        }
        return aggregateId;
    }
    /// <summary>
    ///     Get all aggregate events for a aggregate.
    ///     Aggregate can be specified by aggregateId and rootPartitionKey and aggregateType.
    /// </summary>
    /// <param name="aggregateId"></param>
    /// <param name="rootPartitionKey"></param>
    /// <typeparam name="TAggregatePayload"></typeparam>
    /// <returns></returns>
    /// <exception cref="Exception"></exception>
    public IReadOnlyCollection<IEvent> GetAllAggregateEvents<TAggregatePayload>(
        Guid aggregateId,
        string rootPartitionKey = IDocument.DefaultRootPartitionKey) where TAggregatePayload : IAggregatePayloadCommon
    {
        var toReturn = new List<IEvent>();
        var documentRepository = serviceProvider.GetRequiredService(typeof(IDocumentRepository)) as IDocumentRepository ??
            throw new SekibanTypeNotFoundException("Failed to get document repository");
        documentRepository.GetAllEventsForAggregateIdAsync(
                aggregateId,
                typeof(TAggregatePayload),
                PartitionKeyGenerator.ForEvent(aggregateId, typeof(TAggregatePayload), rootPartitionKey),
                null,
                rootPartitionKey,
                eventObjects => { toReturn.AddRange(eventObjects); })
            .Wait();
        return toReturn;
    }
}
