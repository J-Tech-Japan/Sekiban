# Sekiban.Pure.Dapr with Protobuf Support

This package provides Dapr integration for Sekiban.Pure with enhanced Protobuf serialization support for improved
performance and cross-language compatibility.

## Features

- **Protobuf Serialization**: All actor communication uses Protocol Buffers for efficient binary serialization
- **Compression Support**: Built-in GZIP compression for large payloads
- **Type Registry**: Runtime type resolution with alias support for smaller message sizes
- **Backward Compatibility**: JSON fallback for existing data
- **Batch Operations**: Efficient batch saving of events
- **Multi-language Ready**: Protobuf format enables future cross-language support

## Installation

```bash
dotnet add package Sekiban.Pure.Dapr
```

## Configuration

### Basic Setup (JSON Serialization)

```csharp
var builder = WebApplication.CreateBuilder(args);

// Register domain types (generated by source generator)
var domainTypes = YourDomainTypes.Generate();

// Add Sekiban with Dapr (JSON)
builder.Services.AddSekibanWithDapr(domainTypes, options =>
{
    options.ActorIdPrefix = "sekiban";
    options.QueryServiceAppId = "query-service";
});

var app = builder.Build();

// Configure Dapr
app.UseRouting();
app.MapActorsHandlers();

app.Run();
```

### Protobuf Setup (Recommended)

```csharp
var builder = WebApplication.CreateBuilder(args);

// Register domain types
var domainTypes = YourDomainTypes.Generate();

// Add Sekiban with Dapr using Protobuf
builder.Services.AddSekibanWithDaprProtobuf(domainTypes,
    daprOptions =>
    {
        daprOptions.ActorIdPrefix = "sekiban";
        daprOptions.QueryServiceAppId = "query-service";
    },
    serializationOptions =>
    {
        serializationOptions.EnableCompression = true;
        serializationOptions.CompressionThreshold = 1024; // Compress if > 1KB
        serializationOptions.EnableTypeAliases = true;
    });

var app = builder.Build();

// Configure Dapr
app.UseRouting();
app.MapActorsHandlers();

// Map command endpoints
app.MapPost("/api/command", async (
    [FromBody] ICommandWithHandlerSerializable command,
    ISekibanExecutor executor) =>
{
    var result = await executor.CommandAsync(command);
    return result.ToCommandResponse();
});

app.Run();
```

## Usage

### Executing Commands

```csharp
public class UserController : ControllerBase
{
    private readonly ISekibanExecutor _executor;

    public UserController(ISekibanExecutor executor)
    {
        _executor = executor;
    }

    [HttpPost("users")]
    public async Task<IActionResult> CreateUser([FromBody] CreateUserCommand command)
    {
        var result = await _executor.CommandAsync(command);
        
        if (result.IsSuccess)
        {
            return Ok(result.GetValue());
        }
        
        return BadRequest(result.GetException().Message);
    }
}
```

### Loading Aggregates

```csharp
// Load aggregate by ID
var partitionKeys = new PartitionKeys(userId, string.Empty, "default");
var result = await _executor.LoadAggregateAsync<UserProjector>(partitionKeys);

if (result.IsSuccess)
{
    var user = result.GetValue();
    // Use the aggregate
}
```

### Querying Data

```csharp
// Execute a query
var query = new GetUserByEmailQuery { Email = "user@example.com" };
var result = await _executor.QueryAsync(query);

// Execute a list query
var listQuery = new GetActiveUsersQuery { PageSize = 20 };
var listResult = await _executor.QueryAsync(listQuery);
```

## Dapr Configuration

### State Store Component

```yaml
# components/statestore.yaml
apiVersion: dapr.io/v1alpha1
kind: Component
metadata:
  name: sekiban-eventstore
spec:
  type: state.redis  # or state.cosmosdb, state.postgresql
  version: v1
  metadata:
  - name: redisHost
    value: localhost:6379
```

### PubSub Component

```yaml
# components/pubsub.yaml
apiVersion: dapr.io/v1alpha1
kind: Component
metadata:
  name: sekiban-pubsub
spec:
  type: pubsub.redis  # or pubsub.azure.servicebus
  version: v1
  metadata:
  - name: redisHost
    value: localhost:6379
```

## Protobuf Message Format

The Protobuf definitions are in `Protos/sekiban.proto`:

- `ProtobufCommandEnvelope`: Wraps commands with metadata
- `ProtobufEventEnvelope`: Wraps events with versioning info
- `ProtobufAggregateEnvelope`: Wraps aggregate state
- `ProtobufCommandResponse`: Command execution results

## Migration from JSON to Protobuf

The system supports gradual migration:

1. **Phase 1**: Deploy with `useJsonFallback: true` (default)
    - New data saved as Protobuf
    - Can still read existing JSON data

2. **Phase 2**: Run migration tool (coming soon)
    - Converts existing JSON data to Protobuf
    - Validates data integrity

3. **Phase 3**: Disable JSON fallback
    - Set `useJsonFallback: false`
    - Pure Protobuf operation

## Performance Considerations

- **Compression**: Automatically compresses payloads > 1KB
- **Type Aliases**: Use short aliases instead of full type names
- **Batch Operations**: Use `SaveEventsBatchAsync` for multiple events
- **Actor Reuse**: Actors remain in memory for 30 minutes by default

## Troubleshooting

### Actor Not Found

Ensure actors are registered:

```csharp
services.AddActors(options =>
{
    options.Actors.RegisterActor<ProtobufAggregateActor>();
    // ... other actors
});
```

### Serialization Errors

Check type registration:

```csharp
// In production, this is done by source generator
DaprGeneratedTypeRegistry.RegisterAll(registry);
```

### Performance Issues

Enable caching:

```csharp
services.AddSingleton<CachedDaprSerializationService>();
```

## Future Enhancements

- Cross-language support (Python, Java, Go clients)
- Streaming for large event collections
- Advanced querying with Dapr state query API
- Event sourcing snapshots
- Distributed tracing integration