# concept.md

このドキュメントは「会議室予約＋設備＋承認（ロール承認）」サンプルにおける  
**要求定義（Requirements）**と **設計コンセプト（Concept）**を、  
実装・コード・型定義を一切使わず、**言葉だけ**でまとめたものです。

本サンプルの狙いは「イベントソーシング + DCB を **説明できる最小実用例**」を提示することにあります。

---

## 1. このサンプルが解こうとしている問題

### 1.1 実務でよくあるが、サンプルになりにくい課題

多くのイベントソーシングのサンプルは、次のような違和感を持たれがちです。

- 銀行口座のように単純すぎて、実務の判断が見えない
- 単一集約で完結し、複数集約の一貫性が話題にならない
- 「最終的整合性で我慢する」前提が暗黙になっている
- null やフラグで状態を表し、ドメインルールが見えにくい

一方、実務では次のような状況が頻繁に発生します。

- 複数のリソースを同時に押さえる必要がある
- 条件により処理フローが分岐する
- 承認や期限切れなど、人や時間が絡む判断が入る
- 「片方だけ成功」は業務的に許されない

このサンプルは、その **「実務で当たり前だが、サンプル化が難しい領域」**を、
あえて最小構成で切り出しています。

---

## 2. ドメインの前提（業務の現実）

### 2.1 会議室予約は “部屋だけ” では成立しない

会議室予約は、単に部屋の空き時間を押さえるだけでは完結しません。

- プロジェクタやマイクなど、共有設備を同時に使う場合がある
- 社外者が参加する場合、承認が必要になることがある
- 営業時間外や特定の部屋では、必ず承認が必要な場合がある
- 承認待ちの間も、設備を仮押さえしなければならない場合がある

これらは **業務としては自然**ですが、  
「単一集約」「単一トランザクション」の考え方では扱いづらい要素です。

---

## 3. 本サンプルの要求定義（Requirements）

### 3.1 機能要件

- 会議室の予約を作成・変更・確定・キャンセルできる
- 必要に応じて設備を仮確保・割当できる
- 条件により承認フローを必須にできる
- 承認は特定ユーザーではなく、**ロールを持つ任意のユーザー**が行える
- 承認期限・仮確保期限が切れた場合、自動的に失効する
- 予約・承認・確保の履歴がすべて追跡可能である

### 3.2 非機能要件（設計上の要求）

- 「予約だけ確定」「設備だけ確保」といった **部分成功を残さない**
- 複数集約にまたがる処理でも、業務上の一貫性を保てる
- Read Model（一覧・カレンダー）が矛盾した状態を観測しにくい
- 実装が複雑になりすぎず、説明可能である

---

## 4. 設計コンセプト ①  
## 「1つの事実を、1つのイベントとして記録する」

本サンプルの最大の設計方針は次の一点です。

> **業務的に不可分な事実は、必ず1つのイベントとして記録する**

たとえば、

- 「予約が確定した」
- 「その結果、設備も確定割当された」

これは業務上 **別々の出来事ではありません**。  
「予約が確定した」という事実の一部です。

そのため本サンプルでは、

- 予約確定イベント
- 設備割当イベント

を分けず、**1つのイベント**として扱います。

---

## 5. 設計コンセプト ②  
## Dynamic Consistency Boundary（DCB）

### 5.1 なぜ “Dynamic” なのか

従来のイベントソーシングでは、

- 強い一貫性の境界 = 集約
- 集約をまたぐ処理 = サガ + 最終的整合性

という整理が一般的です。

しかし実務では、

- ある操作では単一集約で十分
- 別の操作では複数集約が不可分

というケースが混在します。

DCB は、この現実をそのまま表現します。

> **一貫性の境界は、集約ではなく “事実” によって動的に決まる**

---

### 5.2 DCB の考え方（言葉で）

- イベントは「何が起きたか」を表す
- その出来事が関係する集約を、イベント側で明示する
- フレームワークは、同じイベントに紐づいた集約群を  
  **同じ一貫性境界として扱う**

これにより、

- 予約と設備
- 予約と承認

といった関係を、  
「後から整合させる対象」ではなく  
**「最初から同時に成立する事実」**として扱えます。

---

## 6. 設計コンセプト ③  
## サガは “整合性を作らない”

本サンプルでは、サガ（プロセス）は存在しますが、
その役割は限定的です。

サガがやること：

- 次に何をすべきかを決める
- 期限切れを検知する
- ユーザー操作や通知と連携する

サガが **やらないこと**：

- 部分成功を補償で帳尻合わせする
- 複数集約の整合性を自前で作る

整合性は、**DCBイベントそのもの**が保証します。

---

## 7. 設計コンセプト ④  
## 状態は「値」ではなく「型」で表す

### 7.1 null やフラグが生む問題

- `approvalRequestId == null` なら未承認
- `holdId != null` なら仮確保済み

こうした設計は、

- 読みにくい
- 状態の組み合わせが爆発する
- 不正な状態がコンパイル時に防げない

という問題を生みます。

---

### 7.2 本サンプルの方針

> **状態そのものを型として定義する**

- 下書き
- 仮確保済み
- 承認待ち
- 承認済み・未確定
- 確定
- キャンセル
- 期限切れ

これらは「フラグの組み合わせ」ではなく、
**互いに排他的な状態**です。

型で表現することで、

- 許可される操作が自明になる
- null チェックが不要になる
- 不正な遷移を自然に排除できる

という効果が得られます。

---

## 8. 設計コンセプト ⑤  
## コマンドは「状態型」を要求する

本サンプルでは、

- 「どのコマンドが実行できるか」
- 「今の状態で許される操作は何か」

を、  
**if 文やフラグではなく、状態型の組み合わせ**で表現します。

これにより、

- ビジネスルールがコード構造に現れる
- 実装者が “やってはいけない操作” をしにくくなる
- レビューや説明が容易になる

---

## 9. このサンプルで伝えたいこと（まとめ）

このサンプルは、

- 高度な分散トランザクションの解決策
- 魔法のような一貫性保証

を示すものではありません。

代わりに、次の問いに答えるためのものです。

- **「なぜ、この事実は1つのイベントであるべきなのか？」**
- **「どこまでを“同時に成立する事実”とみなすのか？」**
- **「一貫性境界を、固定の集約から解放すると何が見えるか？」**

DCB はテクニックではなく、  
**“事実をどう切り出すか” というモデリングの選択**です。

このサンプルは、その選択を **説明可能な形で提示する**ことを目的としています。