# Sekiban Event Sourcing Framework - Complete Documentation

This comprehensive documentation covers all aspects of the Sekiban Event Sourcing Framework, a modern .NET framework for building event-sourced applications with Orleans integration.

---

## Table of Contents

1. [Core Concepts](#core-concepts)
2. [Getting Started](#getting-started)
3. [Aggregate Payload, Projector, Command and Events](#aggregate-payload-projector-command-and-events)
4. [Multiple Aggregate Projector](#multiple-aggregate-projector)
5. [Query](#query)
6. [Workflow](#workflow)
7. [JSON and Orleans Serialization](#json-and-orleans-serialization)
8. [API Implementation](#api-implementation)
9. [Client API (Blazor)](#client-api-blazor)
10. [Orleans Setup](#orleans-setup)
11. [Unit Testing](#unit-testing)
12. [Common Issues and Solutions](#common-issues-and-solutions)
13. [ResultBox](#resultbox)
14. [Value Object](#value-object)

---

## Core Concepts

Event Sourcing: Store all state changes as immutable events. Current state is derived by replaying events.

### Naming Conventions

- Commands: Imperative verbs (Create, Update, Delete)
- Events: Past tense verbs (Created, Updated, Deleted)
- Aggregates: Nouns representing domain entities
- Projectors: Named after the aggregate they project

### Key Principles of Event Sourcing

Event sourcing is an architectural pattern where:

1. **State Changes as Events**: All changes to application state are stored as a sequence of events
2. **Immutable Event Log**: Once recorded, events are never modified or deleted
3. **Current State via Projection**: The current state is calculated by replaying events in sequence
4. **Complete Audit Trail**: The event log provides a complete history of all changes

### Benefits of Using Sekiban

1. **Full History**: Complete audit trail of all domain changes
2. **Time Travel**: Ability to reconstruct state at any point in time
3. **Domain Focus**: Better separation of concerns with clear domain models
4. **Scalability**: Can scale read and write operations independently
5. **Event-Driven Architecture**: Natural integration with event-driven systems

### Core Components

- **Aggregate**: Domain entity that encapsulates state and business rules
- **Command**: Represents user intention to change system state
- **Event**: Immutable record of a state change that has occurred
- **Projector**: Builds current state by applying events to aggregates
- **Query**: Retrieves data from the system based on current state

### PartitionKeys: Event Stream Management

PartitionKeys is a fundamental concept in Sekiban that manages physical event streams. Each event stream is uniquely identified by a PartitionKeys object with three components:

```csharp
using Sekiban.Pure.Documents;

public record PartitionKeys(
    Guid AggregateId,
    string Group,
    string RootPartitionKey);
```

1. **AggregateId (Guid)**: The unique identifier for a specific aggregate instance
2. **AggregateGroup (string)**: Usually the same as the projector name
3. **RootPartitionKey (string)**: Used for tenant separation and data partitioning

**Example of using PartitionKeys:**

```csharp
// For new aggregates
PartitionKeys keys = PartitionKeys.Generate<UserProjector>();

// For existing aggregates
PartitionKeys keys = PartitionKeys.Existing<UserProjector>(existingId);

// With custom tenant/partition
PartitionKeys keys = PartitionKeys.Generate<UserProjector>("tenant123");
```

### Aggregate Design Principles

#### Aggregate Responsibilities

1. **Business Rule Enforcement**: Aggregates validate business invariants before events are generated
2. **Consistency Boundary**: Each aggregate maintains its own consistency without depending on other aggregates
3. **Event Generation**: Aggregates handle commands and produce events as the result of business operations
4. **State Management**: Current aggregate state is derived by applying events in sequence

#### Performance Considerations

- **Event Count Limitation**: Design aggregate streams to have lifecycles with **10,000 events or fewer**
- **Stream Partitioning**: Consider partitioning streams at appropriate boundaries for long-lived aggregates
- **Snapshot Functionality**: Consider using snapshot functionality for aggregates with large numbers of events

#### Aggregate Authorization Rules

- **NO Authentication/Authorization Logic**: Aggregates should not contain authentication or authorization logic
- **Pure Business Logic**: Focus only on domain rules and business invariants
- **Separation of Concerns**: Authorization is handled at the Workflow level

#### Command Design Principles

- **Internal Consistency Only**: Commands should only consider consistency within the aggregate
- **External Information Input**: All required external information must be provided as command parameters
- **No Retrieval Operations**: Commands must not execute external data retrieval operations
- **Deterministic Behavior**: Commands should always return the same result for the same input

### Multi-Tenant Aggregate Design

All aggregates (except Tenant itself) must include TenantId:

```csharp
[GenerateSerializer]
public record TimeSheetProjector : IProjector<TimeSheetProjector>
{
    public TenantId TenantId { get; init; } = new(Guid.Empty);
    public UserId UserId { get; init; } = new(Guid.Empty);
    public DateTime Date { get; init; }
    public List<TimeEntry> Entries { get; init; } = new();
}
```

### Workflow Design Principles

#### Workflow Responsibilities

1. **Cross-Aggregate Operations**: Coordinate operations across multiple aggregates
2. **Authorization & Authentication**: Implement RBAC-based access control
3. **Business Process Orchestration**: Handle complex business workflows
4. **External System Integration**: Manage interactions with external services

---

## Getting Started

### Installation and Setup

```bash
# Install the Sekiban templates
dotnet new install Sekiban.Pure.Templates

# Create a new project
dotnet new sekiban-orleans-aspire -n MyProject
```

This template includes Aspire host for Orleans, Cluster Storage, Grain Persistent Storage, and Queue Storage.

### Important Notes

#### Correct Namespaces
The template uses the `Sekiban.Pure.*` namespace hierarchy, not `Sekiban.Core.*`. Always use the following namespaces:

- `Sekiban.Pure.Aggregates` for aggregates and payload interfaces
- `Sekiban.Pure.Events` for events
- `Sekiban.Pure.Projectors` for projectors
- `Sekiban.Pure.Command.Handlers` for command handlers
- `Sekiban.Pure.Command.Executor` for command execution context
- `Sekiban.Pure.Documents` for partition keys
- `Sekiban.Pure.Query` for queries
- `ResultBoxes` for result handling

### Project Structure

The template creates a solution with multiple projects:
- `MyProject.Domain` - Contains domain models, events, commands, and queries
- `MyProject.ApiService` - API endpoints for commands and queries
- `MyProject.Web` - Web frontend with Blazor
- `MyProject.AppHost` - Aspire host for orchestrating services
- `MyProject.ServiceDefaults` - Common service configurations

### File Structure

```
YourProject.Domain/
├── Aggregates/                         // Aggregate-related folder
│   └── YourEntity/                     // Entity-specific folder
│       ├── Commands/                   // Commands
│       ├── Events/                     // Events
│       ├── Payloads/                   // Aggregate payloads
│       ├── Queries/                    // Queries
│       └── YourEntityProjector.cs      // Projector
├── Projections/                        // Multi-projections
├── ValueObjects/                       // Value objects
└── YourDomainEventsJsonContext.cs      // JSON Context
```

### Initial Steps

1. **Define your domain model**: Start by identifying the key entities in your domain
2. **Create aggregates**: Implement aggregate payloads for each entity
3. **Define commands**: Create commands that represent user intentions
4. **Define events**: Create events that record state changes
5. **Implement projectors**: Create projectors that build current state from events
6. **Add queries**: Add query types to retrieve data
7. **Configure serialization**: Set up JSON serialization for your domain types
8. **Add API endpoints**: Create API endpoints for your commands and queries

---

## Aggregate Payload, Projector, Command and Events

### 1. Aggregate Payload (Domain Entity)

An aggregate is a domain entity that encapsulates state and business rules. In Sekiban, aggregates are implemented as immutable records:

```csharp
using Orleans.Serialization.Attributes;
using Sekiban.Pure.Aggregates;

[GenerateSerializer]
public record YourAggregate(...properties...) : IAggregatePayload
{
    // Domain logic methods
}
```

**Required**:
- Implement `IAggregatePayload` interface
- Use C# record for immutability
- Add `[GenerateSerializer]` attribute for Orleans

#### Example: User Aggregate

```csharp
[GenerateSerializer]
public record User(string Name, string Email, bool IsConfirmed = false) : IAggregatePayload
{
    public User WithConfirmation() => this with { IsConfirmed = true };
    public User UpdateEmail(string newEmail) => this with { Email = newEmail };
}
```

### 2. Commands (User Intentions)

Commands represent user intentions to change system state:

```csharp
[GenerateSerializer]
public record YourCommand(...parameters...) 
    : ICommandWithHandler<YourCommand, YourAggregateProjector>
{
    // For new aggregates:
    public PartitionKeys SpecifyPartitionKeys(YourCommand command) => 
        PartitionKeys.Generate<YourAggregateProjector>();
        
    // For existing aggregates:
    // public PartitionKeys SpecifyPartitionKeys(YourCommand command) => 
    //    PartitionKeys.Existing<YourAggregateProjector>(command.AggregateId);

    public ResultBox<EventOrNone> Handle(YourCommand command, ICommandContext<IAggregatePayload> context)
    {
        // Pure business logic only - no external data retrieval
        return EventOrNone.Event(new YourEvent(...parameters...));
    }
}
```

#### Using the Third Generic Parameter for State Constraints

```csharp
[GenerateSerializer]
public record RevokeUser(Guid UserId) 
    : ICommandWithHandler<RevokeUser, UserProjector, ConfirmedUser>
{
    public PartitionKeys SpecifyPartitionKeys(RevokeUser command) => 
        PartitionKeys<UserProjector>.Existing(UserId);
    
    public ResultBox<EventOrNone> Handle(RevokeUser command, ICommandContext<ConfirmedUser> context) =>
        context
            .GetAggregate()
            .Conveyor(_ => EventOrNone.Event(new UserUnconfirmed()));
}
```

#### Generating Multiple Events from a Command

```csharp
public ResultBox<EventOrNone> Handle(ComplexCommand command, ICommandContext<TAggregatePayload> context)
{
    context.AppendEvent(new FirstEventHappened(command.SomeData));
    context.AppendEvent(new SecondEventHappened(command.OtherData));
    
    return EventOrNone.None;
}
```

### 3. Events (Facts That Happened)

Events contain domain-specific data that record state changes:

```csharp
[GenerateSerializer]
public record YourEvent(...parameters...) : IEventPayload;
```

**Required**:
- Implement `IEventPayload` interface for domain-specific data only
- Use past tense naming (Created, Updated, Deleted)
- Add `[GenerateSerializer]` attribute
- Include all data needed to reconstruct domain state

#### Example: User Events

```csharp
[GenerateSerializer]
public record UserCreated(string Name, string Email) : IEventPayload;

[GenerateSerializer]
public record UserConfirmed : IEventPayload;

[GenerateSerializer]
public record EmailChanged(string NewEmail) : IEventPayload;
```

### 4. Projector (State Builder)

Projectors build the current state by applying events to aggregates:

```csharp
public class UserProjector : IAggregateProjector
{
    public IAggregatePayload Project(IAggregatePayload payload, IEvent ev)
        => (payload, ev.GetPayload()) switch
        {
            (EmptyAggregatePayload, UserCreated e) => new UnconfirmedUser(e.Name, e.Email),
            (UnconfirmedUser user, UserConfirmed _) => new ConfirmedUser(user.Name, user.Email),
            (ConfirmedUser user, UserUnconfirmed _) => new UnconfirmedUser(user.Name, user.Email),
            _ => payload
        };
}
```

### Multiple Projectors for Single Aggregate

You can use multiple projectors on the same event stream using `LoadAggregateAsync`:

```csharp
// Load with the primary projector
var result = await sekibanExecutor.LoadAggregateAsync<UserProjector>(partitionKeys);

// Load the same events with a different projector
var userActivityResult = await sekibanExecutor.LoadAggregateAsync<UserActivityProjector>(partitionKeys);
```

---

## Multiple Aggregate Projector

Multiple aggregate projectors allow you to create views that combine data from multiple aggregates or create specialized projections.

### When to Use Multiple Aggregate Projectors

1. **Cross-Aggregate Views**: When you need to create a view that combines data from multiple aggregates
2. **Specialized Projections**: When you need a specialized view of aggregate data
3. **Filtered Collections**: When you need a filtered subset of aggregates based on certain criteria
4. **Real-time Dashboard Data**: When you need to maintain counters or summaries across aggregates

### Built-in Multi-Projectors

#### 1. AggregateListProjector

Maintains a collection of all aggregates of a specific type:

```csharp
[GenerateSerializer]
public record ListYourEntitiesQuery() 
    : IMultiProjectionListQuery<AggregateListProjector<YourEntityProjector>, ListYourEntitiesQuery, YourEntityResult>
{
    public static ResultBox<IEnumerable<YourEntityResult>> HandleFilter(
        MultiProjectionState<AggregateListProjector<YourEntityProjector>> state,
        ListYourEntitiesQuery query,
        IQueryContext context)
    {
        return state.Payload.Aggregates
            .Where(m => m.Value.GetPayload() is YourEntity)
            .Select(m => MapToResult((YourEntity)m.Value.GetPayload(), m.Key))
            .ToResultBox();
    }
    
    // Other required methods...
}
```

#### 2. EventHistoryProjector

Maintains the full history of events for an aggregate:

```csharp
[GenerateSerializer]
public record GetEventHistoryQuery(Guid AggregateId)
    : IMultiProjectionQuery<EventHistoryProjector<YourEntityProjector>, GetEventHistoryQuery, List<EventHistoryItem>>
{
    public static ResultBox<List<EventHistoryItem>> HandleQuery(
        MultiProjectionState<EventHistoryProjector<YourEntityProjector>> state,
        GetEventHistoryQuery query,
        IQueryContext context)
    {
        if (!state.Payload.EventHistories.TryGetValue(query.AggregateId, out var events))
        {
            return new List<EventHistoryItem>();
        }
        
        return events
            .Select(e => new EventHistoryItem(e.Id, e.Timestamp, e.Version, e.GetPayload().GetType().Name))
            .ToList();
    }
}
```

### Creating Custom Multi-Projectors

```csharp
[GenerateSerializer]
public class OrderStatisticsProjector : IMultiProjector
{
    [Id(0)]
    public int TotalOrders { get; private set; }
    
    [Id(1)]
    public decimal TotalRevenue { get; private set; }
    
    [Id(2)]
    public Dictionary<string, int> ProductSales { get; private set; } = new();
    
    [Id(3)]
    public Dictionary<string, CustomerStats> CustomerStatistics { get; private set; } = new();
}
```

---

## Query

Sekiban supports two types of queries: List Queries and Non-List Queries.

### List Query

List Queries return collections of items and support filtering and sorting operations:

```csharp
[GenerateSerializer]
public record YourListQuery(string FilterParameter = null)
    : IMultiProjectionListQuery<AggregateListProjector<YourAggregateProjector>, YourListQuery, YourListQuery.ResultRecord>
{
    public static ResultBox<IEnumerable<ResultRecord>> HandleFilter(
        MultiProjectionState<AggregateListProjector<YourAggregateProjector>> projection, 
        YourListQuery query, 
        IQueryContext context)
    {
        return projection.Payload.Aggregates
            .Where(m => m.Value.GetPayload() is YourAggregate)
            .Select(m => ((YourAggregate)m.Value.GetPayload(), m.Value.PartitionKeys))
            .Select(tuple => new ResultRecord(tuple.PartitionKeys.AggregateId, ...other properties...))
            .ToResultBox();
    }

    public static ResultBox<IEnumerable<ResultRecord>> HandleSort(
        IEnumerable<ResultRecord> filteredList, 
        YourListQuery query, 
        IQueryContext context)
    {
        return filteredList.OrderBy(m => m.SomeProperty).AsEnumerable().ToResultBox();
    }

    [GenerateSerializer]
    public record ResultRecord(Guid Id, ...other properties...);
}
```

### Non-List Query

Non-List Queries return a single result:

```csharp
[GenerateSerializer]
public record YourNonListQuery(string Parameter)
    : IMultiProjectionQuery<AggregateListProjector<YourAggregateProjector>, YourNonListQuery, bool>
{
    public static ResultBox<bool> HandleQuery(
        MultiProjectionState<AggregateListProjector<YourAggregateProjector>> projection,
        YourNonListQuery query,
        IQueryContext context)
    {
        return projection.Payload.Aggregates.Values
            .Any(aggregate => SomeCondition(aggregate, query.Parameter));
    }
}
```

### Waiting for Specific Events with IWaitForSortableUniqueId

```csharp
[GenerateSerializer]
public record YourQuery(string QueryParam) : 
    IMultiProjectionQuery<YourProjection, YourQuery, YourResult>,
    IWaitForSortableUniqueId
{
    public string? WaitForSortableUniqueId { get; set; }
    
    public static ResultBox<YourResult> HandleQuery(
        MultiProjectionState<YourProjection> state,
        YourQuery query,
        IQueryContext context)
    {
        // Query logic here
    }
}
```

#### Implementation Example

```csharp
// Using the client after executing a command
var commandResult = await client.ExecuteCommandAsync(new YourCommand());
var updatedResult = await client.GetResultAsync(commandResult.LastSortableUniqueId);
```

---

## Workflow

Sekiban supports implementing domain workflows and services that encapsulate business logic spanning multiple aggregates.

### Domain Workflows

Domain workflows are stateless services useful for:

1. **Cross-Aggregate Operations**: When a business process spans multiple aggregates
2. **External Data Retrieval**: When business logic requires data from external systems
3. **Complex Validation**: When validation requires checking against multiple aggregates
4. **Reusable Business Logic**: When the same logic is used in multiple places
5. **Authorization & Security**: Implementing RBAC and authentication logic

```csharp
public class QuestionDisplayWorkflow(ISekibanExecutor executor)
{
    public Task<ResultBox<CommandResponseSimple>> StartDisplayQuestionExclusivelyAsync(
        Guid questionId)
    {
        return executor.QueryAsync(new QuestionsQuery(string.Empty))
            .Conveyor(result => result.Items.Any(q => q.QuestionId == questionId)
                ? result.Items.First(q => q.QuestionId == questionId).ToResultBox()
                : new Exception($"Question not found: {questionId}"))
            .Combine(detail => executor.QueryAsync(
                new QuestionsQuery(string.Empty, detail.QuestionGroupId)))
            .Do((detail, questions) => questions.Items.Where(q => q.IsDisplayed && q.QuestionId != questionId).ToList()
                .ToResultBox().ScanEach(async record =>
                {
                    await executor.CommandAsync(new StopDisplayCommand(record.QuestionId));
                }))
            .Conveyor(items => executor.CommandAsync(new StartDisplayCommand(questionId)).ToSimpleCommandResponse());
    }
}
```

### Implementing a Saga Pattern with Workflows

```csharp
public class OrderSagaWorkflow(ISekibanExecutor executor)
{
    private List<Func<Task<ResultBox<CommandResponseSimple>>>> _compensationActions = new();

    public async Task<ResultBox<CommandResponseSimple>> ProcessOrderAsync(
        Guid orderId, 
        Guid productId, 
        int quantity, 
        Guid customerId, 
        decimal totalAmount)
    {
        // Step 1: Reserve inventory
        var reserveInventoryResult = await executor.CommandAsync(
            new ReserveInventoryCommand(productId, quantity));
            
        if (!reserveInventoryResult.IsSuccess)
        {
            return new Exception("Failed to reserve inventory").ToResultBox<CommandResponseSimple>();
        }
        
        // Register compensation action
        _compensationActions.Add(() => executor.CommandAsync(
            new ReleaseInventoryCommand(productId, quantity)));
            
        // Continue with other steps and compensations...
        
        return reserveInventoryResult.ToSimpleCommandResponse();
    }
    
    private async Task ExecuteCompensationActionsAsync()
    {
        foreach (var action in _compensationActions.AsEnumerable().Reverse())
        {
            try
            {
                await action();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Compensation action failed: {ex.Message}");
            }
        }
        _compensationActions.Clear();
    }
}
```

### Testing Workflows

```csharp
public class OrderSagaWorkflowTests : SekibanInMemoryTestBase
{
    protected override SekibanDomainTypes GetDomainTypes() => 
        OrderProcessDomainTypes.Generate(OrderProcessEventsJsonContext.Default.Options);

    [Fact]
    public async Task ProcessOrder_AllStepsSucceed_OrderIsCreated()
    {
        // Arrange
        var productId = Guid.NewGuid();
        var customerId = Guid.NewGuid();
        var orderId = Guid.NewGuid();
        
        GivenCommand(new CreateInventoryItemCommand(productId, "Test Product", 10));
        GivenCommand(new CreateCustomerCommand(customerId, "Test Customer", 1000m));
        
        // Act
        var workflow = new OrderSagaWorkflow(Executor);
        var result = await workflow.ProcessOrderAsync(orderId, productId, 5, customerId, 100m);
        
        // Assert
        Assert.True(result.IsSuccess);
        
        var inventory = ThenQuery(new GetInventoryItemQuery(productId));
        Assert.Equal(5, inventory.AvailableStock);
    }
}
```

---

## JSON and Orleans Serialization

### JSON Context (For AOT Compilation)

Sekiban uses System.Text.Json's source generators for Ahead-of-Time (AOT) compilation:

```csharp
[JsonSourceGenerationOptions(PropertyNamingPolicy = JsonKnownNamingPolicy.CamelCase)]
[JsonSerializable(typeof(EventDocumentCommon))]
[JsonSerializable(typeof(EventDocumentCommon[]))]
[JsonSerializable(typeof(EventDocument<YourEvent>))]
[JsonSerializable(typeof(YourEvent))]
public partial class YourDomainEventsJsonContext : JsonSerializerContext
{
}
```

### SekibanDomainTypes and Source Generation

Sekiban uses source generation to create domain type registrations:

```csharp
// This class is automatically generated
public static class YourProjectDomainDomainTypes
{
    public static SekibanDomainTypes Generate(JsonSerializerOptions options) => 
        // Implementation is generated based on your domain model
        ...
}
```

**Usage in Application**:
```csharp
// In Program.cs
builder.Services.AddSingleton(
    YourProjectDomainDomainTypes.Generate(
        YourProjectDomainEventsJsonContext.Default.Options));
```

### Orleans Serialization

For all types that need to be serialized in Orleans, add the `[GenerateSerializer]` attribute:

```csharp
[GenerateSerializer]
public record YourCommand(...) : ICommandWithHandler<...>;

[GenerateSerializer]
public record YourEvent(...) : IEventPayload;

[GenerateSerializer]
public record YourAggregate(...) : IAggregatePayload;
```

For non-record types, use the `[Id]` attribute:

```csharp
public class ComplexType
{
    [Id(0)]
    public string PropertyA { get; set; } = null!;

    [Id(1)]
    public int PropertyB { get; set; }
}
```

---

## API Implementation

### Basic Setup Pattern

```csharp
// Program.cs
var builder = WebApplication.CreateBuilder(args);

// 1. Configure Orleans
builder.UseOrleans(config =>
{
    // set your own orleans settings
});

// 2. Register Domain
builder.Services.AddSingleton(
    YourProjectDomainDomainTypes.Generate(
        YourProjectDomainEventsJsonContext.Default.Options));

// 3. Configure Database
builder.AddSekibanCosmosDb();  // or AddSekibanPostgresDb();

// 4. Map Endpoints
var app = builder.Build();
var apiRoute = app.MapGroup("/api");

// Command endpoint pattern
apiRoute.MapPost("/command",
    async ([FromBody] YourCommand command, 
           [FromServices] SekibanOrleansExecutor executor) => 
        await executor.CommandAsync(command).ToSimpleCommandResponse().UnwrapBox());

// Query endpoint pattern
apiRoute.MapGet("/query",
    async ([FromServices] SekibanOrleansExecutor executor) =>
    {
        var result = await executor.QueryAsync(new YourQuery()).UnwrapBox();
        return result.Items;
    });
```

### Using ToSimpleCommandResponse() for Efficient API Endpoints

```csharp
apiRoute
    .MapPost(
        "/inputweatherforecast",
        async (
                [FromBody] InputWeatherForecastCommand command,
                [FromServices] SekibanOrleansExecutor executor) =>
            await executor.CommandAsync(command).ToSimpleCommandResponse().UnwrapBox())
    .WithName("InputWeatherForecast")
    .WithOpenApi();
```

This pattern provides:
1. **Reduced Payload Size**: Converts full CommandResponse to compact CommandResponseSimple
2. **Easy Access to LastSortableUniqueId**: Essential for client-side consistency
3. **Clean API Design**: Combined with `UnwrapBox()`, creates clean, consistent API responses

### Organizing API Endpoints

```csharp
// UserEndpoints.cs
public static class UserEndpoints
{
    public static WebApplication MapUserEndpoints(this WebApplication app)
    {
        var apiGroup = app.MapGroup("/api/users").WithTags("Users");
        
        apiGroup.MapPost("/register",
            async ([FromBody] RegisterUserCommand command, [FromServices] SekibanOrleansExecutor executor) =>
                await executor.CommandAsync(command).ToSimpleCommandResponse().UnwrapBox())
            .WithName("RegisterUser")
            .WithOpenApi();
            
        apiGroup.MapGet("/{userId}",
            async (Guid userId, [FromServices] SekibanOrleansExecutor executor) =>
            {
                var result = await executor.QueryAsync(new GetUserDetailsQuery(userId)).UnwrapBox();
                return result is null ? Results.NotFound() : Results.Ok(result);
            })
            .WithName("GetUserDetails")
            .WithOpenApi();
            
        return app;
    }
}
```

---

## Client API (Blazor)

### Creating an API Client

```csharp
public class YourApiClient(HttpClient httpClient)
{
    public async Task<YourQuery.ResultRecord[]> GetItemsAsync(
        CancellationToken cancellationToken = default)
    {
        List<YourQuery.ResultRecord>? items = null;

        await foreach (var item in httpClient.GetFromJsonAsAsyncEnumerable<YourQuery.ResultRecord>("/api/items", cancellationToken))
        {
            if (item is not null)
            {
                items ??= [];
                items.Add(item);
            }
        }

        return items?.ToArray() ?? [];
    }

    public async Task<CommandResponseSimple> CreateItemAsync(
        string param1,
        string param2,
        CancellationToken cancellationToken = default)
    {
        var command = new CreateYourItemCommand(param1, param2);
        var response = await httpClient.PostAsJsonAsync("/api/createitem", command, cancellationToken);
        response.EnsureSuccessStatusCode();
        return await response.Content.ReadFromJsonAsync<CommandResponseSimple>(cancellationToken: cancellationToken) 
            ?? new CommandResponseSimple();
    }
}
```

### Register the API Client

```csharp
builder.Services.AddHttpClient<YourApiClient>(client =>
{
    client.BaseAddress = new("https+http://apiservice");
});
```

### Create Blazor Components

```cshtml
@page "/items"
@inject YourApiClient ApiClient

<h1>Your Items</h1>

@if (items == null)
{
    <p><em>Loading...</em></p>
}
else
{
    <table class="table">
        <thead>
            <tr>
                <th>ID</th>
                <th>Name</th>
                <th>Description</th>
                <th>Actions</th>
            </tr>
        </thead>
        <tbody>
            @foreach (var item in items)
            {
                <tr>
                    <td>@item.Id</td>
                    <td>@item.Name</td>
                    <td>@item.Description</td>
                    <td>
                        <button class="btn btn-primary" @onclick="() => EditItem(item)">Edit</button>
                    </td>
                </tr>
            }
        </tbody>
    </table>
}

@code {
    private YourQuery.ResultRecord[]? items;
    private string? lastSortableUniqueId;

    protected override async Task OnInitializedAsync()
    {
        await LoadItems();
    }

    private async Task LoadItems()
    {
        items = await ApiClient.GetItemsAsync();
    }

    private async Task CreateItem()
    {
        if (!string.IsNullOrWhiteSpace(newItemName))
        {
            var response = await ApiClient.CreateItemAsync(newItemName, newItemDescription ?? "");
            lastSortableUniqueId = response.LastSortableUniqueId;
            await LoadItems();
        }
    }
}
```

### Using IWaitForSortableUniqueId for Consistent UI

```csharp
public async Task<YourQuery.ResultRecord[]> GetItemsAsync(
    string? waitForSortableUniqueId = null,
    CancellationToken cancellationToken = default)
{
    var uri = "/api/items";
    if (!string.IsNullOrEmpty(waitForSortableUniqueId))
    {
        uri += $"?waitForSortableUniqueId={Uri.EscapeDataString(waitForSortableUniqueId)}";
    }
    
    // Get items with consistency
}

private async Task CreateItem()
{
    var response = await ApiClient.CreateItemAsync(newItemName, newItemDescription ?? "");
    
    // Use the LastSortableUniqueId to ensure we see the updated state
    await LoadItemsWithConsistency(response.LastSortableUniqueId);
}
```

---

## Orleans Setup

Microsoft Orleans provides a framework for building distributed high-scale computing applications. Sekiban integrates with Orleans for robust, scalable event sourcing infrastructure.

### Basic Orleans Configuration

```csharp
// Program.cs
var builder = WebApplication.CreateBuilder(args);

builder.UseOrleans(siloBuilder =>
{
    // For development
    siloBuilder.UseLocalhostClustering();
    
    // Add memory grain storage
    siloBuilder.AddMemoryGrainStorage("PubSubStore");
    
    // Configure serialization
    siloBuilder.Services.AddSingleton<IGrainStorageSerializer, NewtonsoftJsonSekibanOrleansSerializer>();
});
```

### Orleans Clustering Options

#### Development: Local Clustering
```csharp
siloBuilder.UseLocalhostClustering();
```

#### Production: Azure Table Storage Clustering
```csharp
siloBuilder.UseAzureStorageClustering(options =>
{
    options.ConfigureTableServiceClient(builder.Configuration["Orleans:StorageConnectionString"]);
});
```

#### Production: Kubernetes Clustering
```csharp
siloBuilder.UseKubernetesHosting();
```

### Sekiban with Aspire

#### AppHost Project Configuration

```csharp
// Program.cs in the AppHost project
var builder = DistributedApplication.CreateBuilder(args);

var api = builder.AddProject<Projects.ApiService>("apiservice");
var web = builder.AddProject<Projects.Web>("web");

web.WithReference(api);

var postgres = builder.AddPostgres("postgres");
api.WithReference(postgres);

await builder.BuildApplication().RunAsync();
```

#### ServiceDefaults Project Configuration

```csharp
public static class ServiceDefaultsExtensions
{
    public static IHostApplicationBuilder AddServiceDefaults(this IHostApplicationBuilder builder)
    {
        builder.AddDefaultHealthChecks();
        builder.Services.AddServiceDiscovery();

        builder.UseOrleans(siloBuilder =>
        {
            if (builder.Environment.IsDevelopment())
            {
                siloBuilder.UseLocalhostClustering();
            }
            else
            {
                siloBuilder.UseAzureStorageClustering(options =>
                {
                    options.ConfigureTableServiceClient(
                        builder.Configuration.GetConnectionString("OrleansStorage"));
                });
            }

            siloBuilder.AddMemoryGrainStorage("PubSubStore");
            siloBuilder.Services.AddSingleton<IGrainStorageSerializer, NewtonsoftJsonSekibanOrleansSerializer>();
        });

        return builder;
    }
}
```

### Orleans Dashboard

```csharp
siloBuilder.UseDashboard(options =>
{
    options.Port = 8081;
    options.HideTrace = true;
    options.CounterUpdateIntervalMs = 10000;
});
```

Access the dashboard at `http://localhost:8081`.

---

## Unit Testing

Sekiban provides several approaches for unit testing your event-sourced applications.

### Setup Testing Project

```bash
dotnet new xunit -n YourProject.Tests
dotnet add package Sekiban.Testing
```

### 1. In-Memory Testing with SekibanInMemoryTestBase

```csharp
using Sekiban.Pure;
using Sekiban.Pure.xUnit;

public class YourTests : SekibanInMemoryTestBase
{
    protected override SekibanDomainTypes GetDomainTypes() => 
        YourDomainTypes.Generate(YourEventsJsonContext.Default.Options);

    [Fact]
    public void SimpleTest()
    {
        // Given - Execute a command and get the response
        var response1 = GivenCommand(new CreateYourEntity("Name", "Value"));
        Assert.Equal(1, response1.Version);

        // When - Execute another command on the same aggregate
        var response2 = WhenCommand(new UpdateYourEntity(response1.PartitionKeys.AggregateId, "NewValue"));
        Assert.Equal(2, response2.Version);

        // Then - Get the aggregate and verify its state
        var aggregate = ThenGetAggregate<YourEntityProjector>(response2.PartitionKeys);
        var entity = (YourEntity)aggregate.Payload;
        Assert.Equal("NewValue", entity.Value);
        
        // Then - Execute a query and verify the result
        var queryResult = ThenQuery(new YourEntityExistsQuery("Name"));
        Assert.True(queryResult);
    }
}
```

### 2. Method Chaining with ResultBox

```csharp
[Fact]
public void ChainedTest()
    => GivenCommandWithResult(new CreateYourEntity("Name", "Value"))
        .Do(response => Assert.Equal(1, response.Version))
        .Conveyor(response => WhenCommandWithResult(new UpdateYourEntity(response.PartitionKeys.AggregateId, "NewValue")))
        .Do(response => Assert.Equal(2, response.Version))
        .Conveyor(response => ThenGetAggregateWithResult<YourEntityProjector>(response.PartitionKeys))
        .Conveyor(aggregate => aggregate.Payload.ToResultBox().Cast<YourEntity>())
        .Do(payload => Assert.Equal("NewValue", payload.Value))
        .UnwrapBox();
```

### 3. Orleans Testing with SekibanOrleansTestBase

```csharp
public class YourOrleansTests : SekibanOrleansTestBase<YourOrleansTests>
{
    public override SekibanDomainTypes GetDomainTypes() => 
        YourDomainTypes.Generate(YourEventsJsonContext.Default.Options);

    [Fact]
    public void OrleansTest() =>
        GivenCommandWithResult(new CreateYourEntity("Name", "Value"))
            .Do(response => Assert.Equal(1, response.Version))
            .Conveyor(response => WhenCommandWithResult(new UpdateYourEntity(response.PartitionKeys.AggregateId, "NewValue")))
            .Conveyor(response => ThenGetAggregateWithResult<YourEntityProjector>(response.PartitionKeys))
            .Do(payload => Assert.Equal("NewValue", payload.Value))
            .UnwrapBox();
            
    [Fact]
    public void TestSerializable()
    {
        CheckSerializability(new CreateYourEntity("Name", "Value"));
    }
}
```

### Testing Workflows

```csharp
public class DuplicateCheckWorkflowsTests : SekibanInMemoryTestBase
{
    protected override SekibanDomainTypes GetDomainTypes() => 
        YourDomainDomainTypes.Generate(YourDomainEventsJsonContext.Default.Options);

    [Fact]
    public async Task CheckUserIdDuplicate_WhenUserIdExists_ReturnsDuplicate()
    {
        // Arrange
        var existingUserId = "U12345";
        var command = new RegisterUserCommand("John Doe", existingUserId, "john@example.com");

        GivenCommand(command);

        // Act
        var result = await DuplicateCheckWorkflows.CheckUserIdDuplicate(command, Executor);

        // Assert
        Assert.True(result.IsDuplicate);
        Assert.Contains(existingUserId, result.ErrorMessage);
        Assert.Null(result.CommandResult);
    }

    [Fact]
    public async Task CheckUserIdDuplicate_WhenUserIdDoesNotExist_ReturnsSuccess()
    {
        // Arrange
        var newUserId = "U67890";
        var command = new RegisterUserCommand("Jane Doe", newUserId, "jane@example.com");

        // Act
        var result = await DuplicateCheckWorkflows.CheckUserIdDuplicate(command, Executor);

        // Assert
        Assert.False(result.IsDuplicate);
        Assert.Null(result.ErrorMessage);
        Assert.NotNull(result.CommandResult);
    }
}
```

### Testing with Given-When-Then Pattern

```csharp
[Fact]
public void UserRegistrationAndConfirmation()
{
    // Given - A registered user
    var registeredUserResponse = GivenCommand(new RegisterUserCommand(
        "John Doe", 
        "john@example.com", 
        "Password123"));
    
    var userId = registeredUserResponse.PartitionKeys.AggregateId;
    
    // Then - User should be in unconfirmed state
    var unconfirmedAggregate = ThenGetAggregate<UserProjector>(registeredUserResponse.PartitionKeys);
    Assert.IsType<UnconfirmedUser>(unconfirmedAggregate.Payload);
    
    // When - Confirm the user
    var confirmationResponse = WhenCommand(new ConfirmUserCommand(userId));
    
    // Then - User should be in confirmed state
    var confirmedAggregate = ThenGetAggregate<UserProjector>(confirmationResponse.PartitionKeys);
    Assert.IsType<ConfirmedUser>(confirmedAggregate.Payload);
}
```

### Testing Multi-Projectors

```csharp
[Fact]
public void MultiProjectorTest()
{
    // Given - Order placed
    var placeOrderResponse = GivenCommand(new PlaceOrderCommand(
        "customer123",
        new[] { new OrderItemDto("product1", 2, 10.0m) }));
        
    // When - Another order placed
    var placeOrder2Response = WhenCommand(new PlaceOrderCommand(
        "customer123",
        new[] { new OrderItemDto("product2", 1, 15.0m) }));
        
    // Then - OrderStatistics should reflect both orders
    var statistics = ThenGetMultiProjector<OrderStatisticsProjector>();
    
    Assert.Equal(2, statistics.TotalOrders);
    Assert.Equal(35.0m, statistics.TotalRevenue);
}
```

---

## Common Issues and Solutions

### 1. Namespace Errors

**Issue**: Compiler errors due to incorrect namespaces.

**Solution**: Use `Sekiban.Pure.*` namespaces, not `Sekiban.Core.*`:

```csharp
using Sekiban.Pure.Aggregates;
using Sekiban.Pure.Events;
using Sekiban.Pure.Projectors;
using Sekiban.Pure.Command.Handlers;
using Sekiban.Pure.Command.Executor;
using Sekiban.Pure.Documents;
using Sekiban.Pure.Query;
using Sekiban.Pure.ResultBoxes;
```

### 2. Command Context Errors

**Issue**: Cannot access aggregate payload directly from command context.

**Solution**: Use pattern matching or the three-parameter version:

```csharp
// Pattern matching approach
public ResultBox<EventOrNone> Handle(YourCommand command, ICommandContext<IAggregatePayload> context)
{
    if (context.GetAggregate().GetPayload() is YourAggregate aggregate)
    {
        var property = aggregate.Property;
        return EventOrNone.Event(new YourEvent(...));
    }
    
    return new SomeException("Expected YourAggregate");
}

// Three-parameter approach
public record YourCommand(...) 
    : ICommandWithHandler<YourCommand, YourProjector, YourAggregateType>
{
    public ResultBox<EventOrNone> Handle(YourCommand command, ICommandContext<YourAggregateType> context)
    {
        var payload = context.GetAggregate().Payload; // Already typed
        return EventOrNone.Event(new YourEvent(...));
    }
}
```

### 3. Time Unified Acquisition - SekibanDateProducer

**Issue**: Time acquisition methods are not unified.

**Solution**: Use `SekibanDateProducer`:

```csharp
var currentTime = SekibanDateProducer.GetRegistered().UtcNow;
```

### 4. Serialization Issues

**Issue**: Orleans serialization requires types to be serializable.

**Solution**: Add `[GenerateSerializer]` attribute:

```csharp
[GenerateSerializer]
public record YourCommand(...);

[GenerateSerializer]
public record YourEvent(...);

[GenerateSerializer]
public record YourAggregate(...);
```

### 5. Source Generation Issues

**Issue**: Missing `YourProjectDomainDomainTypes` class.

**Solution**:
1. Ensure your project compiles successfully
2. Check that domain types have required attributes
3. Use correct namespace: `using YourProject.Domain.Generated;`
4. Rebuild the solution

### 6. Query Result Issues

**Issue**: Query returns stale results after executing a command.

**Solution**: Use `IWaitForSortableUniqueId`:

```csharp
var commandResult = await executor.CommandAsync(new YourCommand(...)).UnwrapBox();
var query = new YourQuery(...) { WaitForSortableUniqueId = commandResult.LastSortableUniqueId };
var queryResult = await executor.QueryAsync(query).UnwrapBox();
```

### 7. Multiple Events from Command

**Issue**: Need to return multiple events from a command handler.

**Solution**: Use `AppendEvent` method:

```csharp
public ResultBox<EventOrNone> Handle(ComplexCommand command, ICommandContext<TAggregatePayload> context)
{
    context.AppendEvent(new FirstEventHappened(command.SomeData));
    context.AppendEvent(new SecondEventHappened(command.OtherData));
    
    return EventOrNone.None;
}
```

### 8. Orleans Clustering Issues

**Solution**: Check clustering configuration:

```csharp
// For development
siloBuilder.UseLocalhostClustering();

// For production with Azure Storage
siloBuilder.UseAzureStorageClustering(options =>
{
    options.ConfigureTableServiceClient(connectionString);
});
```

### 9. Database Configuration

**Solution**: Check appsettings.json:

```json
{
  "Sekiban": {
    "Database": "Cosmos",
    "Cosmos": {
      "ConnectionString": "your-connection-string",
      "DatabaseName": "your-database-name"
    }
  }
}
```

### 10. Testing Issues

**Solution**: Use `CheckSerializability` for testing:

```csharp
[Fact]
public void TestSerializable()
{
    CheckSerializability(new YourCommand(...));
    CheckSerializability(new YourEvent(...));
}
```

### 11. Performance Issues

**Solution**:
1. Implement event snapshots
2. Use appropriate database indexing
3. Optimize queries for specific patterns
4. Consider multiple projections
5. Use pagination for large result sets

### 12. Concurrency Issues

**Solution**: Implement optimistic concurrency control:

```csharp
public ResultBox<EventOrNone> Handle(YourCommand command, ICommandContext<YourAggregateType> context)
{
    if (context.GetAggregate().Version != command.ExpectedVersion)
    {
        return new ConcurrencyException(
            $"Expected version {command.ExpectedVersion} but found {context.GetAggregate().Version}");
    }
    
    return EventOrNone.Event(new YourEvent(...));
}
```

---

## ResultBox

ResultBox is a powerful utility type from the `ResultBoxes` package essential to Sekiban domain and API code.

### What is ResultBox?

ResultBox is a container that wraps a result value with information about operation success. It provides:

1. **Error Handling** - Safely manages errors without throwing exceptions
2. **Method Chaining** - Allows fluent composition of operations
3. **Unwrapping** - Extracts the final value or throws an exception if any step failed

### Basic Usage

```csharp
public ResultBox<User> GetUserById(string id)
{
    if (string.IsNullOrEmpty(id))
    {
        return ResultBox.Error<User>("User ID cannot be empty");
    }
    
    var user = repository.FindUser(id);
    if (user == null)
    {
        return ResultBox.Error<User>($"User with ID {id} not found");
    }
    
    return ResultBox.Ok(user);
}
```

### Method Chaining with ResultBox

Key extension methods:

1. **Conveyor** - Transforms the result into a new ResultBox if operation was successful
2. **Do** - Executes an action on the value if operation was successful
3. **UnwrapBox** - Extracts the value or throws an exception if operation failed

#### Method Chaining in API Implementation

```csharp
[HttpPost("createuser")]
public async Task<ActionResult<CommandResponseSimple>> CreateUser(
    [FromBody] CreateUserCommand command,
    [FromServices] SekibanOrleansExecutor executor)
{
    return await executor.CommandAsync(command)
        .ToSimpleCommandResponse()
        .UnwrapBox();
}
```

#### Method Chaining in Testing

```csharp
[Fact]
public void ChainedTest()
    => GivenCommandWithResult(new CreateYourEntity("Name", "Value"))
        .Do(response => Assert.Equal(1, response.Version))
        .Conveyor(response => WhenCommandWithResult(new UpdateYourEntity(response.PartitionKeys.AggregateId, "NewValue")))
        .Do(response => Assert.Equal(2, response.Version))
        .Conveyor(response => ThenGetAggregateWithResult<YourEntityProjector>(response.PartitionKeys))
        .Conveyor(aggregate => aggregate.Payload.ToResultBox().Cast<YourEntity>())
        .Do(payload => Assert.Equal("NewValue", payload.Value))
        .UnwrapBox();
```

### Error Handling with ResultBox

```csharp
public async Task<ResultBox<CommandResponseSimple>> ExecuteCommand(CreateItemCommand command)
{
    try
    {
        var result = await executor.CommandAsync(command);
        
        if (!result.IsSuccess)
        {
            return ResultBox.Error<CommandResponseSimple>(result.ErrorMessage);
        }
        
        return result.ToSimpleCommandResponse();
    }
    catch (Exception ex)
    {
        return ResultBox.Error<CommandResponseSimple>(ex.Message);
    }
}
```

### Best Practices

1. **Prefer Method Chains** - Use method chaining rather than unwrapping prematurely
2. **Unwrap at Boundaries** - Only call `UnwrapBox()` at application boundaries like API controllers
3. **Meaningful Error Messages** - Provide clear error messages when creating error ResultBoxes
4. **Transform with Conveyor** - Use `Conveyor` to transform values while maintaining success/failure state
5. **Side Effects with Do** - Use `Do` for assertions or logging without breaking the chain

---

## Value Object

Value Objects represent objects whose equality is based on their values rather than identity.

### Basic Implementation Approach

#### 1. Using Record Types

```csharp
[GenerateSerializer]
public record TemperatureCelsius([property:Range(-273.15, 1000000.0, ErrorMessage = "Temperature cannot be below absolute zero (-273.15°C)")] double Value)
{
    public double GetFahrenheit() => Value * 9 / 5 + 32;
}
```

#### 2. Attribute-Based Validation

Always use `System.ComponentModel.DataAnnotations` attributes:

```csharp
[GenerateSerializer]
public record Email([property:EmailAddress(ErrorMessage = "Invalid email format")] string Value);

[GenerateSerializer]
public record Age([property:Range(0, 150, ErrorMessage = "Age must be between 0 and 150")] int Value);

[GenerateSerializer]
public record ProductName([property:Required, property:StringLength(100, MinimumLength = 1, ErrorMessage = "Product name must be between 1 and 100 characters")] string Value);
```

#### 3. Important Constraints

##### ❌ No Validation in Constructor

```csharp
// ❌ Bad example - Don't do this
[GenerateSerializer]
public record Price(decimal Value)
{
    public Price(decimal Value) : this()
    {
        if (Value < 0)
            throw new ArgumentException("Price cannot be negative"); // NOT allowed!
    }
}
```

##### ❌ No Validation in Static Properties

```csharp
// ❌ Bad example - Don't do this
[GenerateSerializer]
public record UserId(string Value)
{
    public static UserId Create(string value)
    {
        if (string.IsNullOrEmpty(value))
            throw new ArgumentException("UserId cannot be null or empty"); // NOT allowed!
        
        return new UserId(value);
    }
}
```

#### 4. Why Attribute-Based Validation is Required

In Sekiban's event sourcing, event replay occurs when reconstructing aggregates. If validation is in constructors or static methods, previously valid data might fail current validation rules.

**Correct Flow**:
1. **Command Input**: Attribute-based validation is executed
2. **Event Generation**: Events are created with validated data
3. **Event Replay**: Objects are constructed directly without validation

#### 5. Complex Value Object Example

```csharp
[GenerateSerializer]
public record Money(
    [property:Range(0, double.MaxValue, ErrorMessage = "Amount must be positive")]
    decimal Amount,
    
    [property:RegularExpression(@"^[A-Z]{3}$", ErrorMessage = "Currency must be a 3-letter code")]
    string CurrencyCode)
{
    public Money ConvertTo(string newCurrencyCode, decimal exchangeRate)
    {
        return new Money(Amount * exchangeRate, newCurrencyCode);
    }

    public string FormatDisplay() => $"{Amount:F2} {CurrencyCode}";
}
```

### Best Practices

- ✅ Use record types
- ✅ Use attribute-based validation
- ✅ Add `[GenerateSerializer]`
- ✅ Add meaningful methods
- ❌ Don't throw in constructors
- ❌ Don't validate in static properties

### Using Value Objects in Events and Commands

```csharp
[GenerateSerializer]
public record ProductPriceChanged(
    ProductId ProductId,
    Money OldPrice,
    Money NewPrice,
    DateTime ChangedAt) : IEvent;

[GenerateSerializer]
public record ChangeProductPrice(
    ProductId ProductId,
    Money NewPrice) : ICommandWithHandler<ChangeProductPrice, ProductProjector>;
```

### JSON Serialization Configuration

Value Objects must be added to your `JsonSerializerContext`:

```csharp
[JsonSourceGenerationOptions(PropertyNamingPolicy = JsonKnownNamingPolicy.CamelCase)]
[JsonSerializable(typeof(EventDocumentCommon))]

// Add Value Objects
[JsonSerializable(typeof(Money))]
[JsonSerializable(typeof(Email))]
[JsonSerializable(typeof(ProductId))]

// Events using Value Objects
[JsonSerializable(typeof(EventDocument<ProductPriceChanged>))]
[JsonSerializable(typeof(ProductPriceChanged))]

public partial class YourDomainEventsJsonContext : JsonSerializerContext
{
}
```

---

## Summary

Sekiban is a powerful, modern .NET framework for building event-sourced applications with Orleans integration. It provides:

- **Strong Typing**: Type-safe commands, events, and aggregates
- **Clean Architecture**: Clear separation between domain logic, workflows, and API layers
- **Scalability**: Built on Orleans for distributed, high-performance applications
- **Developer Experience**: Source generation, comprehensive testing tools, and fluent APIs
- **Flexibility**: Support for multiple projections, complex workflows, and various deployment scenarios

By following the patterns and best practices outlined in this documentation, you can build robust, maintainable event-sourced applications that scale with your business needs.

For more information, visit the [Sekiban GitHub repository](https://github.com/J-Tech-Japan/Sekiban) or explore the sample applications provided with the framework.
