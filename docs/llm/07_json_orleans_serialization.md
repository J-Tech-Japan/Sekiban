# JSON and Orleans Serialization - Sekiban Event Sourcing

> **Navigation**
> - [Core Concepts](01_core_concepts.md)
> - [Getting Started](02_getting_started.md)
> - [Aggregate, Projector, Command and Events](03_aggregate_command_events.md)
> - [Multiple Aggregate Projector](04_multiple_aggregate_projector.md)
> - [Query](05_query.md)
> - [Workflow](06_workflow.md)
> - [JSON and Orleans Serialization](07_json_orleans_serialization.md) (You are here)
> - [API Implementation](08_api_implementation.md)
> - [Client API (Blazor)](09_client_api_blazor.md)
> - [Orleans Setup](10_orleans_setup.md)
> - [Dapr Setup](11_dapr_setup.md)
> - [Unit Testing](12_unit_testing.md)
> - [Common Issues and Solutions](13_common_issues.md)
> - [ResultBox](14_result_box.md)
> - [Value Object](15_value_object.md)
> - [Deployment Guide](16_deployment.md)

## JSON Context (For AOT Compilation)

In Sekiban, JSON serialization is handled through System.Text.Json's source generators for Ahead-of-Time (AOT)
compilation. This provides better performance and compatibility with Native AOT scenarios.

```csharp
using System.Text.Json;
using System.Text.Json.Serialization;
using Sekiban.Core.Events;

[JsonSourceGenerationOptions(PropertyNamingPolicy = JsonKnownNamingPolicy.CamelCase)]
[JsonSerializable(typeof(EventDocumentCommon))]
[JsonSerializable(typeof(EventDocumentCommon[]))]
[JsonSerializable(typeof(EventDocument<YourEvent>))]
[JsonSerializable(typeof(YourEvent))]
// Add all event types
public partial class YourDomainEventsJsonContext : JsonSerializerContext
{
}
```

**Required**:

- Include all event types
- Add `[JsonSourceGenerationOptions]` attribute
- Define as partial class

## Example: Complete JSON Context for a Domain

Here's a more complete example showing how to register all types for a sample domain:

```csharp
using System.Text.Json;
using System.Text.Json.Serialization;
using Sekiban.Core.Events;
using YourProject.Domain.Aggregates.Orders.Events;
using YourProject.Domain.Aggregates.Products.Events;
using YourProject.Domain.Aggregates.Users.Events;

namespace YourProject.Domain;

[JsonSourceGenerationOptions(
    PropertyNamingPolicy = JsonKnownNamingPolicy.CamelCase,
    WriteIndented = false)]
[JsonSerializable(typeof(EventDocumentCommon))]
[JsonSerializable(typeof(EventDocumentCommon[]))]

// Order events
[JsonSerializable(typeof(EventDocument<OrderCreated>))]
[JsonSerializable(typeof(OrderCreated))]
[JsonSerializable(typeof(EventDocument<OrderPaid>))]
[JsonSerializable(typeof(OrderPaid))]
[JsonSerializable(typeof(EventDocument<OrderCancelled>))]
[JsonSerializable(typeof(OrderCancelled))]
[JsonSerializable(typeof(EventDocument<OrderShipped>))]
[JsonSerializable(typeof(OrderShipped))]

// Product events
[JsonSerializable(typeof(EventDocument<ProductCreated>))]
[JsonSerializable(typeof(ProductCreated))]
[JsonSerializable(typeof(EventDocument<ProductUpdated>))]
[JsonSerializable(typeof(ProductUpdated))]
[JsonSerializable(typeof(EventDocument<ProductPriceChanged>))]
[JsonSerializable(typeof(ProductPriceChanged))]
[JsonSerializable(typeof(EventDocument<ProductDiscontinued>))]
[JsonSerializable(typeof(ProductDiscontinued))]

// User events
[JsonSerializable(typeof(EventDocument<UserRegistered>))]
[JsonSerializable(typeof(UserRegistered))]
[JsonSerializable(typeof(EventDocument<UserEmailVerified>))]
[JsonSerializable(typeof(UserEmailVerified))]
[JsonSerializable(typeof(EventDocument<UserPasswordChanged>))]
[JsonSerializable(typeof(UserPasswordChanged))]
[JsonSerializable(typeof(EventDocument<UserDeactivated>))]
[JsonSerializable(typeof(UserDeactivated))]

// Add additional event types as needed
public partial class YourProjectDomainEventsJsonContext : JsonSerializerContext
{
}
```

## Naming and Organization

The JSON context class should:

1. Be placed in the domain project's root namespace
2. Be named according to your domain, usually `{YourProject}DomainEventsJsonContext`
3. Include all event types used in your domain

## SekibanDomainTypes and Source Generation

### Understanding SekibanDomainTypes

Sekiban uses source generation to create domain type registrations at build time. This is a key part of the framework
that simplifies domain model registration and ensures type safety.

```csharp
// This class is automatically generated by Sekiban.Pure.SourceGenerator
// You don't need to create it manually
public static class YourProjectDomainDomainTypes
{
    // Used for registering domain types with the DI container
    public static SekibanDomainTypes Generate(JsonSerializerOptions options) => 
        // Implementation is generated based on your domain model
        ...

    // Used for serialization checking
    public static SekibanDomainTypes Generate() => 
        Generate(new JsonSerializerOptions());
}
```

### Key Points About Source Generation

1. **Naming Convention**:
    - The generated class follows the pattern `[ProjectName]DomainDomainTypes`
    - For example, a project named "SchoolManagement" will have `SchoolManagementDomainDomainTypes`

2. **Namespace**:
    - The generated class is placed in the `[ProjectName].Generated` namespace
    - For example, `SchoolManagement.Domain.Generated`

3. **Usage in Application**:
   ```csharp
   // In Program.cs
   builder.Services.AddSingleton(
       YourProjectDomainDomainTypes.Generate(
           YourProjectDomainEventsJsonContext.Default.Options));
   ```

4. **Usage in Tests**:
   ```csharp
   // In test classes
   protected override SekibanDomainTypes GetDomainTypes() => 
       YourProjectDomainDomainTypes.Generate(
           YourProjectDomainEventsJsonContext.Default.Options);
   ```

5. **Required Imports for Tests**:
   ```csharp
   using YourProject.Domain;
   using YourProject.Domain.Generated; // Contains the generated types
   using Sekiban.Pure;
   using Sekiban.Pure.xUnit;
   ```

### Troubleshooting Source Generation

1. **Missing Generated Types**:
    - Ensure the project builds successfully before running tests
    - Check that all domain types have the required attributes
    - Look for build warnings related to source generation

2. **Namespace Errors**:
    - Make sure to import the correct Generated namespace
    - The namespace is not visible in source files, only in compiled assemblies

3. **Type Not Found Errors**:
    - Ensure you're using the correct naming convention
    - Check for typos in the class name

## Orleans Serialization

Sekiban leverages Orleans' serialization system for distributed messaging and storage. Orleans requires all types that
are passed between grains to be serializable.

### Using the GenerateSerializer Attribute

For all types that need to be serialized in Orleans, add the `[GenerateSerializer]` attribute. This includes:

1. Commands
2. Events
3. Aggregates (payload records)
4. Query results
5. Query parameters

```csharp
// Command example
[GenerateSerializer]
public record CreateOrderCommand(...) : ICommandWithHandler<...>
{
    // Implementation
}

// Event example
[GenerateSerializer]
public record OrderCreated(...) : IEventPayload
{
    // Implementation
}

// Aggregate payload example
[GenerateSerializer]
public record Order(...) : IAggregatePayload
{
    // Implementation
}

// Query result example
[GenerateSerializer]
public record OrderSummary(...)
{
    // Implementation
}
```

### Field and Property Serialization

For non-record types, Orleans requires you to specify which fields should be serialized using the `[Id]` attribute:

```csharp
public class ComplexType
{
    [Id(0)]
    public string PropertyA { get; set; } = null!;

    [Id(1)]
    public int PropertyB { get; set; }

    [Id(2)]
    public List<string> Items { get; set; } = new();
}
```

For simple records, the properties are automatically serialized without needing explicit `[Id]` attributes.

### Custom Orleans Serializer

If you need to customize Orleans serialization, Sekiban provides a way to use Newtonsoft.Json instead of the default
System.Text.Json:

```csharp
// Example custom Orleans serializer using Newtonsoft.Json
public class NewtonsoftJsonSekibanOrleansSerializer : IGrainStorageSerializer
{
    private readonly JsonSerializerSettings _settings;

    public NewtonsoftJsonSekibanOrleansSerializer() =>
        _settings = new JsonSerializerSettings
        {
            // Similar to IncludeFields = true in System.Text.Json
            ContractResolver = new DefaultContractResolver()
        };
    public BinaryData Serialize<T>(T input)
    {
        var json = JsonConvert.SerializeObject(input, _settings);
        return BinaryData.FromString(json);
    }

    public T Deserialize<T>(BinaryData input)
    {
        var json = input.ToString();
        return JsonConvert.DeserializeObject<T>(json, _settings);
    }
}
```

### Registering Custom Serializer

```csharp
// In Program.cs
builder.UseOrleans(siloBuilder =>
{
    siloBuilder.AddMemoryGrainStorage("PubSubStore");
    
    // Use custom serializer
    siloBuilder.Services.AddSingleton<IGrainStorageSerializer, NewtonsoftJsonSekibanOrleansSerializer>();
    
    // Other Orleans configuration
});
```

## Best Practices

1. **Use Records for DTOs**: Use C# records for all Data Transfer Objects (DTOs) to ensure immutability and simplified
   serialization
2. **Register All Event Types**: Make sure all event types are registered in the JSON context
3. **Proper Namespace Organization**: Keep your types in their proper namespaces
4. **Avoid Circular Dependencies**: Avoid circular dependencies in your type hierarchy
5. **Test Serialization**: Use unit tests to verify that your types can be properly serialized and deserialized
6. **Versioning Strategy**: Plan for versioning of your events to ensure backward compatibility
7. **Keep Events Simple**: Keep event payloads simple and focused to avoid serialization issues